#!/usr/bin/env python3
import os
import sys
import select
import termios
import tty
import pty
import signal
import time
import fcntl
import struct

class TerminalWrapper:
    def __init__(self, command):
        self.command = command
        self.master_fd = None
        self.slave_fd = None
        self.timeout = 5.0  # seconds to wait before sending /next
        self.last_activity_time = time.time()
        self.startup_time = None
        self.setup_sent = False
        
    def setup_pty(self):
        """Create a pseudo-terminal pair"""
        self.master_fd, self.slave_fd = pty.openpty()
        
        # Make master non-blocking
        flags = fcntl.fcntl(self.master_fd, fcntl.F_GETFL)
        fcntl.fcntl(self.master_fd, fcntl.F_SETFL, flags | os.O_NONBLOCK)
        
        # Set terminal to xterm-256color
        os.environ['TERM'] = 'xterm-256color'
        
        # Get current terminal size and apply to PTY
        try:
            # Get size from the controlling terminal (stdin)
            rows, cols = struct.unpack('HHHH', fcntl.ioctl(0, termios.TIOCGWINSZ, '\0' * 8))[:2]
            if rows == 0 or cols == 0:
                # Fallback to os.get_terminal_size
                rows, cols = os.get_terminal_size()
            
            # Apply size to both master and slave
            size = struct.pack('HHHH', rows, cols, 0, 0)
            fcntl.ioctl(self.master_fd, termios.TIOCSWINSZ, size)
            fcntl.ioctl(self.slave_fd, termios.TIOCSWINSZ, size)
            
            # Also set environment variables
            os.environ['LINES'] = str(rows)
            os.environ['COLUMNS'] = str(cols)
        except:
            # Final fallback
            try:
                rows, cols = 24, 80  # Default terminal size
                size = struct.pack('HHHH', rows, cols, 0, 0)
                fcntl.ioctl(self.slave_fd, termios.TIOCSWINSZ, size)
            except:
                pass
            
    def make_raw(self, fd):
        """Put terminal in raw mode"""
        attrs = termios.tcgetattr(fd)
        # Use tty.setraw for proper raw mode
        tty.setraw(fd, termios.TCSANOW)
        return attrs
        
    def restore_terminal(self, fd, attrs):
        """Restore terminal attributes"""
        termios.tcsetattr(fd, termios.TCSANOW, attrs)
        
            
    def reset_timeout(self):
        """Reset timeout"""
        self.last_activity_time = time.time()
                
    def send_setup_command(self):
        """Send /setup followed by Enter to the wrapped process"""
        # Add small delays to simulate human typing
        import time as t
        
        # Send Enter to ensure we're on a new line
        os.write(self.master_fd, b'\r')
        t.sleep(0.05)
        
        # Type /setup character by character
        for char in b'/setup':
            os.write(self.master_fd, bytes([char]))
            t.sleep(0.01)
            
        # Send Enter to execute the command
        os.write(self.master_fd, b'\r')
        
        self.setup_sent = True
        self.last_activity_time = time.time()

    def send_next_command(self):
        """Send /next followed by Enter to the wrapped process"""
        # Add small delays to simulate human typing
        import time as t
        
        # Send Enter to ensure we're on a new line
        os.write(self.master_fd, b'\r')
        t.sleep(0.05)
        
        # Type /next character by character
        for char in b'/next':
            os.write(self.master_fd, bytes([char]))
            t.sleep(0.01)
            
        # Send Enter to execute the command
        os.write(self.master_fd, b'\r')
        
        self.last_activity_time = time.time()
        
    def handle_resize(self, signum, frame):
        """Handle terminal resize"""
        try:
            # Get size from the controlling terminal
            rows, cols = struct.unpack('HHHH', fcntl.ioctl(0, termios.TIOCGWINSZ, '\0' * 8))[:2]
            if rows == 0 or cols == 0:
                rows, cols = os.get_terminal_size()
            
            size = struct.pack('HHHH', rows, cols, 0, 0)
            fcntl.ioctl(self.master_fd, termios.TIOCSWINSZ, size)
            
            # Update environment for child
            os.environ['LINES'] = str(rows)
            os.environ['COLUMNS'] = str(cols)
            
        except:
            pass
            
    def run_child_process(self):
        """Run the child process and handle it"""
        # Fork to create child process
        pid = os.fork()
        
        if pid == 0:  # Child process
            os.close(self.master_fd)
            
            # Make slave PTY the controlling terminal
            os.setsid()
            fcntl.ioctl(self.slave_fd, termios.TIOCSCTTY)
            
            # Redirect stdin/stdout/stderr to PTY
            os.dup2(self.slave_fd, 0)
            os.dup2(self.slave_fd, 1)
            os.dup2(self.slave_fd, 2)
            
            # Don't modify slave terminal attributes - let the child process handle its own terminal settings
            
            # Ensure the child gets the correct terminal size
            try:
                rows, cols = struct.unpack('HHHH', fcntl.ioctl(self.slave_fd, termios.TIOCGWINSZ, '\0' * 8))[:2]
                os.environ['LINES'] = str(rows)
                os.environ['COLUMNS'] = str(cols)
            except:
                pass
            
            if self.slave_fd > 2:
                os.close(self.slave_fd)
                
            # Execute the wrapped command
            os.execvp(self.command[0], self.command)
            
        else:  # Parent process
            os.close(self.slave_fd)
            
            # Save and set raw mode for stdin
            stdin_attrs = self.make_raw(sys.stdin.fileno())
            
            # Set startup time for /setup command
            self.startup_time = time.time()
            
            try:
                while True:
                    current_time = time.time()
                    
                    # Check if we need to send /setup command (10 seconds after startup)
                    if not self.setup_sent and current_time - self.startup_time >= 10.0:
                        self.send_setup_command()
                    
                    # Calculate timeout for select
                    elapsed = current_time - self.last_activity_time
                    timeout_remaining = max(0.1, self.timeout - elapsed)
                    
                    # Check for data with timeout
                    rfds, _, _ = select.select([sys.stdin.fileno(), self.master_fd], [], [], min(timeout_remaining, 0.1))
                    
                    # Check if timeout has been reached (only send /next after /setup has been sent)
                    if self.setup_sent and elapsed >= self.timeout:
                        self.send_next_command()
                    
                    if sys.stdin.fileno() in rfds:
                        # Forward user input to wrapped process
                        data = os.read(sys.stdin.fileno(), 1024)
                        if not data:
                            break
                        os.write(self.master_fd, data)
                        # Reset timeout on keystroke
                        self.reset_timeout()
                        
                    if self.master_fd in rfds:
                        # Forward wrapped process output to terminal
                        try:
                            # Read larger chunks for better performance
                            data = os.read(self.master_fd, 65536)
                            if not data:
                                break
                            # Write in binary mode to preserve all control sequences
                            sys.stdout.buffer.write(data)
                            sys.stdout.buffer.flush()
                            # Reset timeout on output
                            self.reset_timeout()
                        except OSError as e:
                            if e.errno == 11:  # EAGAIN
                                continue
                            break
                            
                    # Check if child process is still alive
                    pid_status, _ = os.waitpid(pid, os.WNOHANG)
                    if pid_status != 0:
                        break
                        
            finally:
                # Restore terminal
                self.restore_terminal(sys.stdin.fileno(), stdin_attrs)
                os.close(self.master_fd)
                
                # Clean up child process
                try:
                    os.kill(pid, signal.SIGTERM)
                    os.waitpid(pid, 0)
                except:
                    pass
                    
        return pid
    
    def run(self):
        """Main execution loop with auto-restart"""
        while True:
            try:
                self.setup_pty()
                
                # Set up signal handler for window resize
                signal.signal(signal.SIGWINCH, self.handle_resize)
                
                # Reset state for new session
                self.startup_time = None
                self.setup_sent = False
                self.last_activity_time = time.time()
                
                # Run the child process
                pid = self.run_child_process()
                
                # Wait for child to finish
                _, exit_status = os.waitpid(pid, 0)
                
                # Check exit status
                if os.WIFEXITED(exit_status):
                    exit_code = os.WEXITSTATUS(exit_status)
                    if exit_code == 0:
                        # Normal exit, don't restart
                        break
                    else:
                        print(f"\nProcess exited with code {exit_code}. Restarting...", file=sys.stderr)
                elif os.WIFSIGNALED(exit_status):
                    signal_num = os.WTERMSIG(exit_status)
                    print(f"\nProcess killed by signal {signal_num}. Restarting...", file=sys.stderr)
                else:
                    print("\nProcess crashed. Restarting...", file=sys.stderr)
                
                # Wait a moment before restarting
                time.sleep(1)
                
            except KeyboardInterrupt:
                # User pressed Ctrl+C, exit normally
                break
            except Exception as e:
                print(f"\nError: {e}. Restarting...", file=sys.stderr)
                time.sleep(1)

def main():
    if len(sys.argv) < 2:
        print("Usage: ./cont <command> [args...]", file=sys.stderr)
        sys.exit(1)
        
    command = sys.argv[1:]
    wrapper = TerminalWrapper(command)
    
    try:
        wrapper.run()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(f"\nError: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()