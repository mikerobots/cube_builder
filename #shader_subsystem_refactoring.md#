# Shader Subsystem Refactoring Design

## Executive Summary

This document proposes a refactoring of the shader system in VoxelEditor to create a fully testable, modular shader subsystem. The goal is to isolate shader functionality into a clean, simple interface that enables easy testing, validation, and addition of new shaders without risking rendering pipeline stability.

## Current State Analysis

### Problems with Current Architecture

1. **Tight Coupling**: Shaders are tightly coupled with the rendering system through `ShaderManager` and `OpenGLRenderer`
2. **Mixed Responsibilities**: `ShaderManager` handles compilation, caching, uniform management, and file I/O
3. **Testing Difficulties**: 
   - Tests require OpenGL context initialization
   - Inline shaders scattered across multiple renderer classes
   - No standardized shader validation framework
4. **Shader Source Management**:
   - File-based shaders in `/core/rendering/shaders/`
   - Inline shaders embedded in C++ files (GroundPlaneGrid.cpp, HighlightRenderer.cpp, etc.)
   - No unified shader registry or catalog
5. **Limited Validation**: 
   - Some shaders have no tests (flat_voxel.frag, GL33 variants)
   - Visual validation requires full rendering pipeline
   - No isolated shader compilation tests

## Proposed Architecture

### Core Design Principles

1. **Separation of Concerns**: Isolate shader compilation, validation, and runtime management
2. **Testability First**: Every shader component must be testable without OpenGL context
3. **Shader as Data**: Treat shaders as data assets with metadata, not just strings
4. **Progressive Enhancement**: Support basic to advanced shader features incrementally
5. **Fail-Safe Design**: Invalid shaders should never crash the system

### Component Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Shader Subsystem                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  ┌─────────────────┐  ┌──────────────────┐  ┌────────────┐│
│  │ Shader Registry │  │ Shader Compiler  │  │   Shader   ││
│  │                 │  │                  │  │  Validator ││
│  │ - Catalog       │  │ - Preprocessor   │  │            ││
│  │ - Metadata      │  │ - GLSL Compiler  │  │ - Syntax   ││
│  │ - Versioning    │  │ - Linker         │  │ - Semantic ││
│  └────────┬────────┘  └────────┬─────────┘  └─────┬──────┘│
│           │                     │                   │       │
│  ┌────────┴──────────────────────┴─────────────────┴──────┐│
│  │                  Shader Pipeline API                    ││
│  │                                                         ││
│  │  - loadShader(id) -> ShaderHandle                      ││
│  │  - validateShader(handle) -> ValidationResult          ││
│  │  - compileShader(handle) -> CompiledShader            ││
│  │  - createProgram(shaders[]) -> ProgramHandle          ││
│  └─────────────────────────────────────────────────────────┘│
│                                                             │
│  ┌─────────────────┐  ┌──────────────────┐  ┌────────────┐│
│  │ Shader Library  │  │  Test Framework  │  │   Shader   ││
│  │                 │  │                  │  │   Cache    ││
│  │ - Built-in      │  │ - Mock GL        │  │            ││
│  │ - User-defined  │  │ - Validators     │  │ - Runtime  ││
│  │ - Variants      │  │ - Benchmarks     │  │ - Compiled ││
│  └─────────────────┘  └──────────────────┘  └────────────┘│
└─────────────────────────────────────────────────────────────┘
```

## Detailed Component Design

### 1. Shader Registry

**Purpose**: Central catalog of all shaders with metadata and versioning

```cpp
class ShaderRegistry {
public:
    struct ShaderMetadata {
        std::string id;              // Unique identifier
        std::string name;            // Human-readable name
        std::string category;        // voxel, ui, effect, debug
        ShaderStage stage;           // vertex, fragment, geometry
        std::string glslVersion;     // 330, 410, etc.
        std::vector<std::string> requiredExtensions;
        std::vector<UniformDesc> uniforms;
        std::vector<AttributeDesc> attributes;
        std::vector<std::string> dependencies;
        std::string sourcePath;      // File path or inline marker
        std::string sourceCode;      // Actual GLSL code
        bool isBuiltIn;
        Version version;             // Shader version for updates
    };
    
    // Registry operations
    void registerShader(const ShaderMetadata& metadata);
    void registerBuiltInShaders();
    ShaderMetadata getShader(const std::string& id) const;
    std::vector<std::string> listShaders(const std::string& category = "") const;
    bool hasShader(const std::string& id) const;
    
    // Variant support
    std::string createVariant(const std::string& baseId, 
                            const std::vector<std::string>& defines);
    
    // Import/Export
    void loadFromDirectory(const std::string& path);
    void exportToJSON(const std::string& path) const;
};
```

### 2. Shader Compiler

**Purpose**: Platform-agnostic shader compilation with proper error handling

```cpp
class ShaderCompiler {
public:
    struct CompileOptions {
        std::vector<std::string> defines;
        std::unordered_map<std::string, std::string> macros;
        bool optimizationLevel = 2;
        bool generateDebugInfo = false;
        std::string targetProfile;  // core, compatibility
    };
    
    struct CompileResult {
        bool success;
        std::vector<CompileError> errors;
        std::vector<CompileWarning> warnings;
        std::string infoLog;
        size_t instructionCount;    // For performance analysis
        std::vector<std::string> usedUniforms;
        std::vector<std::string> usedAttributes;
    };
    
    // Compilation interface
    CompileResult compileShader(const std::string& source,
                               ShaderStage stage,
                               const CompileOptions& options);
    
    // Preprocessing
    std::string preprocess(const std::string& source,
                          const CompileOptions& options);
    
    // Platform-specific compilation (mockable for tests)
    virtual uint32_t compileGLSL(const std::string& source,
                                 uint32_t shaderType) = 0;
};

// Test implementation
class MockShaderCompiler : public ShaderCompiler {
    uint32_t compileGLSL(const std::string& source,
                        uint32_t shaderType) override {
        // Validate GLSL syntax without OpenGL
        return validateGLSLSyntax(source, shaderType);
    }
};
```

### 3. Shader Validator

**Purpose**: Comprehensive shader validation without rendering

```cpp
class ShaderValidator {
public:
    struct ValidationRules {
        bool checkSyntax = true;
        bool checkSemantics = true;
        bool checkPerformance = true;
        bool checkPortability = true;
        bool checkBestPractices = true;
        std::vector<std::string> requiredUniforms;
        std::vector<std::string> requiredAttributes;
        size_t maxInstructions = 1000;
        std::vector<std::string> forbiddenFunctions;
    };
    
    struct ValidationResult {
        bool passed;
        std::vector<ValidationIssue> issues;
        PerformanceMetrics metrics;
        PortabilityReport portability;
    };
    
    // Validation methods
    ValidationResult validate(const ShaderMetadata& shader,
                            const ValidationRules& rules);
    
    // Specific validators
    bool validateVertexFragmentInterface(const std::string& vertexCode,
                                       const std::string& fragmentCode);
    bool validateUniformUsage(const std::string& code,
                            const std::vector<UniformDesc>& uniforms);
    bool validateAttributeBindings(const std::string& code,
                                 const std::vector<AttributeDesc>& attributes);
    
    // Performance analysis
    PerformanceMetrics analyzePerformance(const std::string& code);
    
    // Portability checks
    PortabilityReport checkPortability(const std::string& code,
                                     const std::vector<std::string>& targets);
};
```

### 4. Shader Pipeline API

**Purpose**: Clean, simple interface for shader operations

```cpp
class ShaderPipeline {
public:
    // Initialization
    void initialize(std::unique_ptr<ShaderCompiler> compiler);
    void setValidator(std::unique_ptr<ShaderValidator> validator);
    
    // Shader operations
    ShaderHandle loadShader(const std::string& id);
    ValidationResult validateShader(ShaderHandle handle);
    CompiledShader compileShader(ShaderHandle handle,
                                const CompileOptions& options = {});
    ProgramHandle createProgram(const std::vector<CompiledShader>& shaders);
    
    // Runtime operations
    void useProgram(ProgramHandle program);
    void setUniform(ProgramHandle program, const std::string& name,
                   const UniformValue& value);
    
    // Testing support
    void enableTestMode(bool enable);
    TestReport getTestReport() const;
    
    // Hot reload
    void enableHotReload(bool enable);
    void checkForChanges();
    
private:
    std::unique_ptr<ShaderRegistry> m_registry;
    std::unique_ptr<ShaderCompiler> m_compiler;
    std::unique_ptr<ShaderValidator> m_validator;
    std::unique_ptr<ShaderCache> m_cache;
    bool m_testMode = false;
};
```

### 5. Shader Library

**Purpose**: Organized collection of built-in and user shaders

```cpp
namespace ShaderLibrary {
    // Built-in shader IDs
    namespace BuiltIn {
        constexpr const char* BASIC_VOXEL_VERT = "builtin.voxel.basic.vert";
        constexpr const char* BASIC_VOXEL_FRAG = "builtin.voxel.basic.frag";
        constexpr const char* ENHANCED_VOXEL_FRAG = "builtin.voxel.enhanced.frag";
        constexpr const char* FLAT_VOXEL_FRAG = "builtin.voxel.flat.frag";
        constexpr const char* GROUND_PLANE_VERT = "builtin.ground.plane.vert";
        constexpr const char* GROUND_PLANE_FRAG = "builtin.ground.plane.frag";
        constexpr const char* WIREFRAME_VERT = "builtin.debug.wireframe.vert";
        constexpr const char* WIREFRAME_FRAG = "builtin.debug.wireframe.frag";
        // ... more built-in shaders
    }
    
    // Shader templates for common patterns
    namespace Templates {
        std::string generatePhongShader(const PhongParams& params);
        std::string generateOutlineShader(const OutlineParams& params);
        std::string generateGridShader(const GridParams& params);
    }
    
    // Utility functions
    void registerAllBuiltInShaders(ShaderRegistry& registry);
    void loadUserShaders(ShaderRegistry& registry, const std::string& path);
}
```

### 6. Test Framework

**Purpose**: Comprehensive testing without OpenGL dependencies

```cpp
class ShaderTestFramework {
public:
    // Test types
    void runSyntaxTests(const std::string& shaderId);
    void runCompilationTests(const std::string& shaderId);
    void runLinkingTests(const std::vector<std::string>& shaderIds);
    void runValidationTests(const std::string& shaderId,
                          const ValidationRules& rules);
    void runPerformanceTests(const std::string& shaderId);
    void runPortabilityTests(const std::string& shaderId);
    
    // Visual validation (with mock renderer)
    void runVisualTests(const std::string& shaderId,
                       const TestScene& scene,
                       const ExpectedOutput& expected);
    
    // Regression testing
    void captureBaseline(const std::string& shaderId);
    bool compareWithBaseline(const std::string& shaderId);
    
    // Test utilities
    void injectError(const std::string& shaderId, ErrorType type);
    void benchmarkShader(const std::string& shaderId);
    TestReport generateReport() const;
};

// Example test
TEST(ShaderTests, BasicVoxelShaderCompilation) {
    ShaderTestFramework framework;
    framework.runCompilationTests(ShaderLibrary::BuiltIn::BASIC_VOXEL_VERT);
    framework.runCompilationTests(ShaderLibrary::BuiltIn::BASIC_VOXEL_FRAG);
    framework.runLinkingTests({
        ShaderLibrary::BuiltIn::BASIC_VOXEL_VERT,
        ShaderLibrary::BuiltIn::BASIC_VOXEL_FRAG
    });
}
```

## Migration Strategy

### Phase 1: Foundation (Week 1-2)
1. Implement ShaderRegistry with metadata structure
2. Create ShaderCompiler interface with mock implementation
3. Build basic ShaderValidator for syntax checking
4. Set up test framework infrastructure

### Phase 2: Migration (Week 3-4)
1. Register all existing shaders in the registry
2. Extract inline shaders to separate files
3. Add metadata for all shaders
4. Create comprehensive test suite for existing shaders

### Phase 3: Integration (Week 5-6)
1. Implement ShaderPipeline API
2. Update RenderEngine to use new shader subsystem
3. Migrate ShaderManager functionality
4. Ensure backward compatibility

### Phase 4: Enhancement (Week 7-8)
1. Add advanced validation rules
2. Implement performance profiling
3. Create shader documentation generator
4. Build visual regression test suite

## Benefits

### 1. Testability
- Test shaders without OpenGL context
- Validate shader correctness at compile time
- Catch errors before runtime
- Automated regression testing

### 2. Maintainability
- Clear separation of concerns
- Self-documenting shader metadata
- Version control for shader updates
- Easy to add new shaders

### 3. Performance
- Shader compilation caching
- Performance profiling built-in
- Optimized shader variants
- Reduced runtime errors

### 4. Developer Experience
- Simple API for shader operations
- Comprehensive error messages
- Hot reload support
- Visual debugging tools

### 5. Quality Assurance
- Automated validation
- Performance benchmarks
- Portability checks
- Best practice enforcement

## Example Usage

```cpp
// Initialize shader subsystem
ShaderPipeline pipeline;
pipeline.initialize(std::make_unique<GLSLCompiler>());

// Load and validate shader
auto vertHandle = pipeline.loadShader("builtin.voxel.basic.vert");
auto fragHandle = pipeline.loadShader("builtin.voxel.basic.frag");

auto vertResult = pipeline.validateShader(vertHandle);
auto fragResult = pipeline.validateShader(fragHandle);

if (vertResult.passed && fragResult.passed) {
    // Compile shaders
    auto vertCompiled = pipeline.compileShader(vertHandle);
    auto fragCompiled = pipeline.compileShader(fragHandle);
    
    // Create program
    auto program = pipeline.createProgram({vertCompiled, fragCompiled});
    
    // Use in rendering
    pipeline.useProgram(program);
    pipeline.setUniform(program, "mvpMatrix", mvp);
}

// Testing
ShaderTestFramework tests;
tests.runCompilationTests("builtin.voxel.basic.vert");
tests.runVisualTests("builtin.voxel.basic", testScene, expectedOutput);
```

## Conclusion

This refactoring creates a robust, testable shader subsystem that addresses current pain points while providing a foundation for future enhancements. The clean API, comprehensive testing capabilities, and separation of concerns will significantly improve shader development and maintenance workflows.