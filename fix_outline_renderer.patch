--- a/core/visual_feedback/src/OutlineRenderer.cpp
+++ b/core/visual_feedback/src/OutlineRenderer.cpp
@@ -128,11 +128,18 @@ void OutlineRenderer::endBatch() {
 void OutlineRenderer::renderBatch(const Camera::Camera& camera) {
     // Early return if no batches or not initialized
     if (m_batches.empty()) return;
     
+    // Ensure we're initialized before checking batch data
+    ensureInitialized();
+    
+    // Clear any previous OpenGL errors
+    while (glGetError() != GL_NO_ERROR) {}
+    
     // Check if any batch has actual data to render
     bool hasDataToRender = false;
     for (const auto& batch : m_batches) {
         if (!batch.vertices.empty() && !batch.indices.empty()) {
             hasDataToRender = true;
+            // Validate indices are within bounds
+            for (uint32_t idx : batch.indices) {
+                if (idx >= batch.vertices.size()) {
+                    std::cerr << "OutlineRenderer: Invalid index " << idx 
+                             << " >= vertex count " << batch.vertices.size() << std::endl;
+                    return;
+                }
+            }
             break;
         }
     }
     
     if (!hasDataToRender) return;
     
-    ensureInitialized();
-    
     // Check if shader is valid
     if (m_outlineShader == 0) {
         std::cerr << "OutlineRenderer: Cannot render - outline shader is invalid" << std::endl;
@@ -170,9 +180,6 @@ void OutlineRenderer::renderBatch(const Camera::Camera& camera) {
     glUniformMatrix4fv(mvpLoc, 1, GL_FALSE, mvpMatrix.data());
     glUniform1f(animationTimeLoc, m_animationTime);
     
-    // Clear any previous errors
-    while (glGetError() != GL_NO_ERROR) {}
-    
     // Bind VAO (contains all vertex attribute setup)
     glBindVertexArray(m_vertexArray);
     GLenum vaoError = glGetError();
@@ -232,6 +239,9 @@ void OutlineRenderer::renderBatch(const Camera::Camera& camera) {
         // Assert when failing to ensure we are not masking problems
         assert(false && "OpenGL error in OutlineRenderer - failing hard to catch issues early");
     }
+    
+    // Clear batches after rendering to prevent accumulation
+    m_batches.clear();
 }
 
 void OutlineRenderer::clearBatch() {
@@ -496,10 +506,20 @@ void OutlineRenderer::createBuffers() {
 void OutlineRenderer::updateBuffers(const OutlineBatch& batch) {
     if (batch.vertices.empty()) return;
     
+    // Validate indices before uploading
+    for (uint32_t idx : batch.indices) {
+        if (idx >= batch.vertices.size()) {
+            std::cerr << "OutlineRenderer::updateBuffers: Invalid index " << idx 
+                     << " >= vertex count " << batch.vertices.size() << std::endl;
+            return;
+        }
+    }
+    
     // Update vertex buffer
     glBindBuffer(GL_ARRAY_BUFFER, m_vertexBuffer);
     
     // Check if we need to resize the buffer
     GLint bufferSize = 0;
     glGetBufferParameteriv(GL_ARRAY_BUFFER, GL_BUFFER_SIZE, &bufferSize);
+    GLenum error = glGetError();
+    if (error != GL_NO_ERROR) {
+        std::cerr << "OutlineRenderer::updateBuffers: Error getting buffer size: " << error << std::endl;
+        bufferSize = 0; // Force reallocation
+    }
+    
     size_t requiredSize = batch.vertices.size() * sizeof(OutlineVertex);
     
     if (requiredSize > static_cast<size_t>(bufferSize)) {